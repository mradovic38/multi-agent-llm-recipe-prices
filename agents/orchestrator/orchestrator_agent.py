from tools.recipes_rag import RecipesRAG
from agents.ingredients.ingredients_agent import IngredientsAgent
from agents.synthesis.synthesis_agent import SynthesisAgent
from agents import ABCAgent

import re
import traceback


class OrchestratorAgent(ABCAgent):

    def __init__(self, 
                 model, 
                 recipes_rag: RecipesRAG, 
                 ingredients_agent: IngredientsAgent, 
                 prices_agent, 
                 synthesis_agent: SynthesisAgent, 
                 memory_agent=None, 
                 prompt_path:str='agents/orchestrator/prompts/orchestrator_prompt.txt', 
                 params_path='agents/orchestrator/params.json',
                 user_input_tag:str = '<user-input>'):
        
        super().__init__(model, prompt_path, params_path)
        
        self.memory_agent = memory_agent
        self.synthesis_agent = synthesis_agent
        self.ingredients_agent = ingredients_agent
        self.prices_agent = prices_agent

        self.recipes_rag = recipes_rag

        self.user_input_tag = user_input_tag

    def dynamic_method(self):
        """
        A dynamic method that is generated by the LLM. Below is an example of a generated function.

        Returns:
            Date needed to synthesise the response.
        """
        #recipe = self.recipes_rag.retrieve("pizza")
        #ingredients = self.ingredients_agent.extract_ingredients(recipe['ingredients'])
        #prices, total_price = self.prices_agent.get_prices(ingredients)
        #return recipe, prices, total_price
        pass

    def prompt(self, input:str) -> str:
        """
        Generates a function that calls all of the agents needed to respond to user query. Calls synthesis agent to synthesise
        the final response and calls the memory agent to save important data in memory.

        Args:
            input (str): User query.

        Returns:
            str: Response to a user query.
        """

        memory = ''
        if self.memory_agent:
            memory = self.memory_agent.get_memory()
        
        try:
            print("Planning...") # Print to let the user know which step is the current

            code = self._query_llm(input=input, history=memory)

            code = code = code.replace('extract_ingredients', 'self.ingredients_agent.extract_ingredients')
            code = code.replace('get_prices', 'self.prices_agent.get_prices')
            code = code.replace('query_recipes', 'self.recipes_rag.retrieve')

            code = ('\n' + code).replace('\n', '\n    ')
            runner = f"def dynamic_method(self):\n{code}"

            # Display generated function
            print("-"*100)
            print("[ORCHESTRATOR] Generated function:")
            print(runner)
            print("-"*100)

            local_scope = {}
            exec(runner, globals(), local_scope)

            # Bind the dynamically created method to the instance
            self.dynamic_method = local_scope['dynamic_method'].__get__(self)

            # Call the dynamically created method
            result = self.dynamic_method()
            # result = run_python_code()

            if result == [] or not result:
                return "Error generating response: No matching results found."

            response = self.synthesis_agent.synthesize(input, result)
            if response==None:
                return "Error generating response: Synthesis could not be performed."

            
            if self.memory_agent:
                self.memory_agent.memorize(input, response)

            return response

        except Exception:
            return f"Error generating response: Exception:\n{traceback.format_exc()}"
        
    
    def _build_query(self, **kwargs):
        query =  kwargs['input']

        user_input = ''
        if 'history' in kwargs:
            user_input += f'History: {kwargs["history"]}\n'
        user_input += query

        query = self.prompt_text.replace(self.user_input_tag, user_input)

        return query

    def _cleanup_response(self, generated_text):
        code_match = re.search(r"(.*?)```", generated_text, re.DOTALL)

        if code_match:
            generated_code = code_match.group(1).strip()
        else:
            generated_code = "return []"

        return generated_code